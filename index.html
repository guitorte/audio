<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Guitar Riff MIDI Generator</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg:        #0d0d0d;
      --surface:   #1a1a1a;
      --surface2:  #242424;
      --surface3:  #2e2e2e;
      --border:    #333;
      --accent:    #e85d04;
      --accent2:   #f48c06;
      --text:      #e0e0e0;
      --text-dim:  #888;
      --success:   #2ecc71;
      --danger:    #e74c3c;
      --info:      #3498db;
      --radius:    8px;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem 1rem 4rem;
      gap: 1.25rem;
    }

    header { text-align: center; }
    header h1 {
      font-size: clamp(1.3rem, 4vw, 1.8rem);
      font-weight: 700;
      letter-spacing: -0.5px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    header p { color: var(--text-dim); font-size: 0.8rem; margin-top: 0.2rem; }

    /* ── Card ── */
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1.1rem;
      width: 100%;
      max-width: 820px;
    }
    .card-title {
      font-size: 0.68rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--text-dim);
      margin-bottom: 0.85rem;
    }

    /* ── Controls Grid ── */
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 0.8rem;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .control-group label, .section-label {
      font-size: 0.72rem;
      color: var(--text-dim);
      font-weight: 500;
    }
    select, input[type="range"] {
      width: 100%;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 5px;
      color: var(--text);
      padding: 0.4rem 0.5rem;
      font-size: 0.82rem;
      cursor: pointer;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      transition: border-color 0.15s;
    }
    select:hover, select:focus { border-color: var(--accent); }
    select option { background: var(--surface2); }
    input[type="range"] {
      padding: 0; height: 5px; border-radius: 3px;
      accent-color: var(--accent); margin-top: 0.2rem;
    }
    .range-row { display: flex; align-items: center; gap: 0.4rem; }
    .range-row input { flex: 1; }
    .range-val {
      font-size: 0.78rem; font-weight: 600;
      color: var(--accent2); min-width: 2.2rem; text-align: right;
    }

    /* ── Buttons ── */
    .btn-row { display: flex; gap: 0.6rem; flex-wrap: wrap; margin-top: 0.85rem; }
    button {
      display: inline-flex; align-items: center; gap: 0.35rem;
      padding: 0.45rem 0.9rem; border-radius: 5px; border: none;
      font-size: 0.82rem; font-weight: 600; cursor: pointer;
      transition: all 0.12s;
    }
    button:active { transform: scale(0.97); }
    button:disabled { opacity: 0.35; cursor: not-allowed; transform: none; }
    .btn-primary { background: linear-gradient(135deg, var(--accent), var(--accent2)); color: #fff; }
    .btn-primary:hover:not(:disabled) { filter: brightness(1.1); }
    .btn-secondary { background: var(--surface2); border: 1px solid var(--border); color: var(--text); }
    .btn-secondary:hover:not(:disabled) { border-color: var(--accent); color: var(--accent2); }
    .btn-play { background: var(--success); color: #fff; }
    .btn-play:hover:not(:disabled) { filter: brightness(1.1); }
    .btn-stop { background: var(--danger); color: #fff; }
    .btn-stop:hover:not(:disabled) { filter: brightness(1.1); }
    .btn-sm { padding: 0.3rem 0.6rem; font-size: 0.75rem; }
    .btn-xs { padding: 0.2rem 0.45rem; font-size: 0.7rem; border-radius: 4px; }
    .btn-danger-outline { background: transparent; border: 1px solid var(--danger); color: var(--danger); }
    .btn-danger-outline:hover:not(:disabled) { background: var(--danger); color: #fff; }

    /* ── Section cards ── */
    .section-card {
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.8rem;
      margin-bottom: 0.6rem;
    }
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.6rem;
    }
    .section-name {
      font-weight: 700;
      font-size: 1rem;
      color: var(--accent2);
    }
    .section-controls-row {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      gap: 0.6rem;
      margin-bottom: 0.6rem;
    }
    .section-toggles {
      display: flex; gap: 0.8rem; margin-bottom: 0.6rem; flex-wrap: wrap;
    }
    .toggle-label {
      display: flex; align-items: center; gap: 0.3rem;
      font-size: 0.75rem; color: var(--text-dim); cursor: pointer;
      user-select: none;
    }
    .toggle-label input[type="checkbox"] {
      width: auto; height: auto; accent-color: var(--accent);
      cursor: pointer;
    }

    /* ── Rhythm Grid ── */
    .rhythm-grid {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }
    .beat-group {
      display: flex;
      gap: 2px;
      border-right: 1px solid rgba(255,255,255,0.06);
      padding-right: 3px;
    }
    .beat-group:last-child { border-right: none; padding-right: 0; }
    .grid-cell {
      width: 26px; height: 26px;
      border-radius: 3px;
      background: var(--surface3);
      border: 1px solid rgba(255,255,255,0.08);
      cursor: pointer;
      transition: all 0.1s;
    }
    .grid-cell:hover { border-color: var(--accent); }
    .grid-cell.active {
      background: var(--accent);
      border-color: var(--accent2);
      box-shadow: 0 0 6px rgba(232,93,4,0.3);
    }

    /* ── Chord Progression Editor ── */
    .progression-row {
      display: flex; gap: 0.4rem; flex-wrap: wrap;
      align-items: center; margin-top: 0.4rem;
    }
    .progression-row select {
      width: auto; min-width: 60px; padding: 0.3rem 0.4rem; font-size: 0.78rem;
    }

    /* ── Arrangement Editor ── */
    .arrangement-chips {
      display: flex; gap: 0.35rem; flex-wrap: wrap;
      align-items: center; margin-bottom: 0.6rem;
      min-height: 32px;
    }
    .arr-chip {
      display: inline-flex; align-items: center; gap: 0.25rem;
      background: var(--surface3); border: 1px solid var(--border);
      border-radius: 4px; padding: 0.25rem 0.5rem;
      font-size: 0.8rem; font-weight: 600; color: var(--accent2);
      cursor: default;
    }
    .arr-chip .arr-remove {
      cursor: pointer; opacity: 0.5; font-size: 0.9rem;
      line-height: 1; margin-left: 0.1rem;
    }
    .arr-chip .arr-remove:hover { opacity: 1; color: var(--danger); }
    .add-arr-btns { display: flex; gap: 0.3rem; flex-wrap: wrap; margin-bottom: 0.5rem; }

    /* ── Presets ── */
    .preset-row {
      display: flex; gap: 0.4rem; flex-wrap: wrap;
      align-items: center; margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--border);
    }
    .preset-row span { font-size: 0.72rem; color: var(--text-dim); margin-right: 0.2rem; }

    /* ── Piano Roll ── */
    .piano-roll-wrap {
      position: relative; overflow: hidden;
      border-radius: 6px; background: #111;
      border: 1px solid var(--border);
    }
    #pianoRoll { display: block; width: 100%; cursor: default; }
    .playhead {
      position: absolute; top: 0; bottom: 0; width: 2px;
      background: rgba(232,93,4,0.9); pointer-events: none;
      transition: left 0.05s linear;
    }
    #emptyMsg {
      text-align: center; padding: 2.5rem 1rem;
      color: var(--text-dim); font-size: 0.82rem;
    }

    .info-bar {
      display: flex; gap: 1.2rem; flex-wrap: wrap;
      font-size: 0.75rem; color: var(--text-dim);
    }
    .info-bar span { display: flex; gap: 0.25rem; align-items: center; }
    .info-bar strong { color: var(--accent2); }

    .section-markers {
      display: flex; gap: 0; font-size: 0.65rem;
      margin-top: 0.3rem;
    }
    .section-marker {
      text-align: center; padding: 0.15rem 0;
      border: 1px solid var(--border); border-radius: 3px;
      color: var(--text-dim); font-weight: 600;
    }

    #status { font-size: 0.78rem; color: var(--text-dim); min-height: 1.1rem; }
    #status.ok  { color: var(--success); }
    #status.err { color: var(--danger); }

    footer { font-size: 0.7rem; color: var(--text-dim); text-align: center; }
    footer a { color: var(--accent2); text-decoration: none; }

    @media (max-width: 500px) {
      .grid-cell { width: 22px; height: 22px; }
      .controls-grid { grid-template-columns: 1fr 1fr; }
      .section-controls-row { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>

<header>
  <h1>&#127928; Guitar Riff MIDI Generator</h1>
  <p>Crie riffs multi-seção, com power chords e progressões &mdash; ouça e baixe MIDI</p>
</header>

<!-- Global Settings -->
<div class="card">
  <div class="card-title">Configurações Globais</div>
  <div class="controls-grid">
    <div class="control-group">
      <label for="selKey">Tonalidade</label>
      <select id="selKey">
        <option>E</option><option>F</option><option>F#/Gb</option>
        <option>G</option><option>G#/Ab</option><option selected>A</option>
        <option>A#/Bb</option><option>B</option><option>C</option>
        <option>C#/Db</option><option>D</option><option>D#/Eb</option>
      </select>
    </div>
    <div class="control-group">
      <label for="selScale">Escala</label>
      <select id="selScale">
        <option selected>Pentatônica Menor</option>
        <option>Blues</option>
        <option>Menor Natural</option>
        <option>Dórica</option>
        <option>Mixolídia</option>
        <option>Pentatônica Maior</option>
      </select>
    </div>
    <div class="control-group">
      <label for="rangeBpm">BPM</label>
      <div class="range-row">
        <input type="range" id="rangeBpm" min="60" max="220" value="120" />
        <span class="range-val" id="bpmVal">120</span>
      </div>
    </div>
    <div class="control-group">
      <label for="rangeVelocity">Dinâmica</label>
      <div class="range-row">
        <input type="range" id="rangeVelocity" min="40" max="127" value="95" />
        <span class="range-val" id="velVal">95</span>
      </div>
    </div>
  </div>
</div>

<!-- Sections -->
<div class="card">
  <div class="card-title">Seções do Riff</div>
  <div id="sectionsList"></div>
  <button class="btn-secondary btn-sm" id="btnAddSection">+ Adicionar Seção</button>
</div>

<!-- Arrangement -->
<div class="card">
  <div class="card-title">Arranjo</div>
  <div class="arrangement-chips" id="arrangementChips"></div>
  <div class="add-arr-btns" id="addArrBtns"></div>
  <div class="preset-row">
    <span>Presets:</span>
    <button class="btn-secondary btn-xs" data-preset="power-rock">Power Rock</button>
    <button class="btn-secondary btn-xs" data-preset="blues-shuffle">Blues Shuffle</button>
    <button class="btn-secondary btn-xs" data-preset="metal">Metal Riff</button>
    <button class="btn-secondary btn-xs" data-preset="funk">Funk Groove</button>
    <button class="btn-secondary btn-xs" data-preset="pentatonic">Pentatônico</button>
  </div>
</div>

<!-- Actions -->
<div class="card">
  <div class="btn-row">
    <button class="btn-primary" id="btnGenerate">&#9654; Gerar Riff</button>
    <button class="btn-play"   id="btnPlay"     disabled>&#9654; Tocar</button>
    <button class="btn-stop"   id="btnStop"     disabled>&#9632; Parar</button>
    <button class="btn-secondary" id="btnDownload" disabled>&#8595; Baixar MIDI</button>
  </div>
  <p id="status" style="margin-top:0.5rem"></p>
</div>

<!-- Piano Roll -->
<div class="card">
  <div class="card-title">Piano Roll</div>
  <div class="piano-roll-wrap" id="rollWrap">
    <p id="emptyMsg">Gere um riff para visualizar as notas</p>
    <canvas id="pianoRoll" style="display:none"></canvas>
    <div class="playhead" id="playhead" style="display:none; left:0"></div>
  </div>
  <div class="section-markers" id="sectionMarkers"></div>
</div>

<!-- Info -->
<div class="card">
  <div class="card-title">Informações</div>
  <div class="info-bar" id="infoBar">
    <span>Gere um riff para ver os detalhes</span>
  </div>
</div>

<footer>
  100% client-side &mdash; sem servidor. Compatível com GarageBand, REAPER, Ableton, FL Studio.
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

<script>
'use strict';

/* ═══════════════════════════════════════════════════════
   CONSTANTS
═══════════════════════════════════════════════════════ */
const SCALES = {
  'Pentatônica Menor': [0, 3, 5, 7, 10],
  'Blues':             [0, 3, 5, 6, 7, 10],
  'Menor Natural':     [0, 2, 3, 5, 7, 8, 10],
  'Dórica':            [0, 2, 3, 5, 7, 9, 10],
  'Mixolídia':         [0, 2, 4, 5, 7, 9, 10],
  'Pentatônica Maior': [0, 2, 4, 7, 9],
};

const ROOT_MIDI = {
  'E': 40, 'F': 41, 'F#/Gb': 42, 'G': 43, 'G#/Ab': 44,
  'A': 45, 'A#/Bb': 46, 'B': 47, 'C': 48, 'C#/Db': 49, 'D': 50, 'D#/Eb': 51,
};

const CHORD_DEGREES = {
  'I': 0, 'bII': 1, 'II': 2, 'bIII': 3, 'III': 4, 'IV': 5,
  'bV': 6, 'V': 7, 'bVI': 8, 'VI': 9, 'bVII': 10, 'VII': 11,
};
const DEGREE_NAMES = Object.keys(CHORD_DEGREES);

const STYLE_DEFS = {
  'Rock Clássico': {
    velVar: 8, octaveRange: [0, 1], program: 30,
    noteLengthFactor: 0.8, preferRoot: 0.30, preferFifth: 0.18, stepwiseProb: 0.60,
  },
  'Blues Shuffle': {
    velVar: 18, octaveRange: [0, 1], program: 28,
    noteLengthFactor: 0.65, swing: true, preferRoot: 0.25, preferFifth: 0.20, stepwiseProb: 0.55,
  },
  'Metal': {
    velVar: 5, octaveRange: [0, 0], program: 31,
    noteLengthFactor: 0.45, preferRoot: 0.40, preferFifth: 0.25, stepwiseProb: 0.65,
  },
  'Funk': {
    velVar: 22, octaveRange: [0, 2], program: 29,
    noteLengthFactor: 0.35, preferRoot: 0.20, preferFifth: 0.15, stepwiseProb: 0.40,
  },
  'Alternativo': {
    velVar: 20, octaveRange: [0, 1], program: 29,
    noteLengthFactor: 0.70, preferRoot: 0.22, preferFifth: 0.18, stepwiseProb: 0.50,
  },
};

const DEFAULT_RHYTHMS = {
  'Rock Clássico':  [1,0,0,0, 1,0,1,0, 0,0,1,0, 1,0,0,0],
  'Blues Shuffle':   [1,0,1,0, 0,0,1,0, 0,1,1,0, 1,0,0,0],
  'Metal':           [1,1,0,1, 1,0,1,1, 0,1,1,0, 1,1,0,1],
  'Funk':            [1,0,0,1, 0,1,0,0, 1,0,0,1, 0,0,1,0],
  'Alternativo':     [1,0,1,0, 0,1,0,0, 1,0,0,1, 0,1,0,0],
};

const TICKS_PER_BEAT = 480;
const TICKS_16TH = TICKS_PER_BEAT / 4;
const TICKS_PER_BAR = TICKS_PER_BEAT * 4;

/* ═══════════════════════════════════════════════════════
   STATE
═══════════════════════════════════════════════════════ */
let sectionIdCounter = 0;

function createSection(name, overrides = {}) {
  return {
    id: sectionIdCounter++,
    name,
    bars: 2,
    style: 'Rock Clássico',
    complexity: 'Médio',
    powerChords: false,
    palmMute: false,
    noteMode: 'random',          // 'random' | 'progression' | 'motif'
    chordProgression: ['I', 'bVII', 'IV', 'I'],
    rhythm: [...DEFAULT_RHYTHMS['Rock Clássico']],
    ...overrides,
  };
}

const state = {
  sections: [createSection('A')],
  arrangement: ['A'],
};

let currentNotes = null;
let currentMIDI  = null;
let isPlaying    = false;
let playheadTimer = null;
let synth = null;
let part  = null;

const $ = id => document.getElementById(id);

/* ═══════════════════════════════════════════════════════
   MUSIC THEORY & GENERATION
═══════════════════════════════════════════════════════ */
function buildScaleNotes(rootMidi, intervals, octaveRange) {
  const notes = new Set();
  for (let oct = octaveRange[0]; oct <= octaveRange[1] + 1; oct++) {
    for (const iv of intervals) {
      const n = rootMidi + iv + oct * 12;
      if (n >= 36 && n <= 84) notes.add(n);
    }
  }
  return [...notes].sort((a, b) => a - b);
}

function chooseNext(curIdx, scale, rootMidi, styleDef) {
  const r = Math.random();
  const rootIdxs  = scale.map((n,i) => ({n,i})).filter(({n}) => (n - rootMidi) % 12 === 0);
  const fifthIdxs = scale.map((n,i) => ({n,i})).filter(({n}) => (n - rootMidi) % 12 === 7);
  const nearest = (arr) => arr.reduce((a,b) =>
    Math.abs(a.i - curIdx) <= Math.abs(b.i - curIdx) ? a : b);

  if (r < styleDef.preferRoot && rootIdxs.length) return nearest(rootIdxs).i;
  if (r < styleDef.preferRoot + styleDef.preferFifth && fifthIdxs.length) return nearest(fifthIdxs).i;
  if (r < styleDef.preferRoot + styleDef.preferFifth + styleDef.stepwiseProb) {
    const step = Math.random() < 0.55 ? 1 : -1;
    return Math.max(0, Math.min(scale.length - 1, curIdx + step));
  }
  const span = Math.min(4, Math.floor(scale.length / 2));
  const mn = Math.max(0, curIdx - span);
  const mx = Math.min(scale.length - 1, curIdx + span);
  let idx;
  do { idx = mn + Math.floor(Math.random() * (mx - mn + 1)); } while (idx === curIdx && mx > mn);
  return idx;
}

function getDurSteps(step, pattern, complexity) {
  let dur = 1;
  if (complexity !== 'Complexo') {
    for (let i = step + 1; i < pattern.length; i++) {
      if (pattern[i] === 0) dur++; else break;
    }
  }
  return Math.max(1, dur);
}

function addPowerChord(notes, pitch, vel, startTick, durTicks) {
  notes.push({ pitch, velocity: vel, startTick, durationTicks: durTicks });
  notes.push({ pitch: pitch + 7, velocity: Math.round(vel * 0.9), startTick, durationTicks: durTicks });
  notes.push({ pitch: pitch + 12, velocity: Math.round(vel * 0.75), startTick, durationTicks: durTicks });
}

function clampGuitarRange(p) {
  while (p < 40) p += 12;
  while (p > 76) p -= 12;
  return p;
}

/* Generate notes for a single section */
function generateSectionNotes(section, globalKey, globalScale, globalVel) {
  const rootMidi  = ROOT_MIDI[globalKey];
  const intervals = SCALES[globalScale];
  const styleDef  = STYLE_DEFS[section.style];
  const scale     = buildScaleNotes(rootMidi, intervals, styleDef.octaveRange);
  if (!scale.length) return [];

  const rhythm  = section.rhythm;
  const notes   = [];
  const density = { 'Simples': 0.55, 'Médio': 1.0, 'Complexo': 1.35 }[section.complexity] ?? 1.0;

  // Cursor for scale walk
  let curIdx = scale.findIndex(n => (n - rootMidi) % 12 === 0);
  if (curIdx < 0) curIdx = 0;

  // Motif mode: pre-generate a short motif
  let motif = null;
  if (section.noteMode === 'motif') {
    const mLen = 3 + Math.floor(Math.random() * 3);
    motif = [];
    let mi = curIdx;
    for (let m = 0; m < mLen; m++) {
      motif.push(scale[mi]);
      mi = chooseNext(mi, scale, rootMidi, styleDef);
    }
  }

  // Progression mode: split bars among chords
  const prog = section.chordProgression;
  const totalSteps = section.bars * 16;
  const stepsPerChord = prog.length > 0 ? Math.floor(totalSteps / prog.length) : totalSteps;

  let motifPos = 0;
  let motifVariation = 0;

  for (let step = 0; step < totalSteps; step++) {
    const patStep = step % 16;
    if (rhythm[patStep] !== 1) continue;
    if (Math.random() > density) continue;

    // Decide pitch based on noteMode
    let pitch;

    if (section.noteMode === 'progression') {
      const chordIdx = Math.min(prog.length - 1, Math.floor(step / stepsPerChord));
      const chordSemitone = CHORD_DEGREES[prog[chordIdx]] ?? 0;
      const chordRoot = rootMidi + chordSemitone;
      if (Math.random() < 0.65) {
        pitch = clampGuitarRange(chordRoot);
      } else {
        // Passing tone from scale near chord root
        const nearNotes = scale.filter(n => Math.abs(n - chordRoot) <= 5 || Math.abs(n - chordRoot - 12) <= 5);
        pitch = nearNotes.length ? nearNotes[Math.floor(Math.random() * nearNotes.length)] : clampGuitarRange(chordRoot);
      }
    } else if (section.noteMode === 'motif' && motif) {
      let mp = motif[motifPos % motif.length];
      // Apply variation
      if (motifVariation === 1) mp = motif[(motif.length - 1 - motifPos % motif.length)] ?? mp;
      if (motifVariation === 2) mp += 2;
      if (motifVariation === 3 && motifPos % motif.length === motif.length - 1) mp = scale[curIdx];
      pitch = clampGuitarRange(mp);
      motifPos++;
      if (motifPos % motif.length === 0) motifVariation = (motifVariation + 1) % 4;
    } else {
      // Random scale walk
      curIdx = chooseNext(curIdx, scale, rootMidi, styleDef);
      pitch = scale[curIdx];
    }

    const vel = Math.min(127, Math.max(30,
      globalVel + Math.round((Math.random() - 0.5) * styleDef.velVar * 2)));

    let durSteps = getDurSteps(patStep, rhythm, section.complexity);
    let durTicks = Math.max(20, Math.round(durSteps * TICKS_16TH * styleDef.noteLengthFactor));
    if (section.palmMute) durTicks = Math.min(durTicks, Math.round(TICKS_16TH * 0.55));

    let startTick = step * TICKS_16TH;
    if (styleDef.swing && patStep % 2 === 1) startTick += Math.round(TICKS_16TH * 0.20);

    if (section.powerChords) {
      addPowerChord(notes, pitch, vel, startTick, durTicks);
    } else {
      notes.push({ pitch, velocity: vel, startTick, durationTicks: durTicks });
    }
  }

  return notes;
}

/* Generate full riff from arrangement */
function generateFullRiff() {
  const key   = $('selKey').value;
  const scale = $('selScale').value;
  const vel   = parseInt($('rangeVelocity').value);
  const allNotes = [];
  let tickOffset = 0;
  const sectionOffsets = []; // for piano roll markers

  for (const sName of state.arrangement) {
    const sec = state.sections.find(s => s.name === sName);
    if (!sec) continue;

    const secNotes = generateSectionNotes(sec, key, scale, vel);
    const secTicks = sec.bars * TICKS_PER_BAR;
    sectionOffsets.push({ name: sName, startTick: tickOffset, endTick: tickOffset + secTicks });

    for (const n of secNotes) {
      allNotes.push({ ...n, startTick: n.startTick + tickOffset, section: sName });
    }
    tickOffset += secTicks;
  }

  // Add resolving root note at end
  if (allNotes.length) {
    const rootMidi = ROOT_MIDI[key];
    const intervals = SCALES[scale];
    const rootNote = clampGuitarRange(rootMidi);
    const lastTick = Math.max(...allNotes.map(n => n.startTick + n.durationTicks));
    allNotes.push({ pitch: rootNote, velocity: vel, startTick: lastTick + TICKS_16TH, durationTicks: TICKS_PER_BEAT * 2 });
  }

  return { notes: allNotes, sectionOffsets };
}

/* ═══════════════════════════════════════════════════════
   MIDI WRITER
═══════════════════════════════════════════════════════ */
function toVarLen(value) {
  const bytes = [];
  bytes.unshift(value & 0x7F);
  value >>>= 7;
  while (value > 0) { bytes.unshift((value & 0x7F) | 0x80); value >>>= 7; }
  return bytes;
}
function uint32BE(v) { return [(v>>>24)&0xFF,(v>>>16)&0xFF,(v>>>8)&0xFF,v&0xFF]; }
function uint16BE(v) { return [(v>>>8)&0xFF, v&0xFF]; }

function buildMIDI(notes, bpm, program) {
  const tempo = Math.round(60_000_000 / bpm);
  const events = [];
  for (const n of notes) {
    events.push({ tick: n.startTick, type: 0x90, data: [n.pitch, n.velocity] });
    events.push({ tick: n.startTick + n.durationTicks, type: 0x80, data: [n.pitch, 0] });
  }
  events.sort((a, b) => a.tick - b.tick || (a.type === 0x80 ? -1 : 1));

  const td = [];
  const push = (...b) => b.forEach(x => td.push(x));
  push(0x00, 0xFF, 0x51, 0x03, (tempo>>>16)&0xFF, (tempo>>>8)&0xFF, tempo&0xFF);
  push(0x00, 0xFF, 0x58, 0x04, 0x04, 0x02, 0x18, 0x08);
  push(0x00, 0xC0, program & 0x7F);
  const name = Array.from('Guitar Riff', c => c.charCodeAt(0));
  push(0x00, 0xFF, 0x03, name.length, ...name);

  let lastTick = 0;
  for (const ev of events) {
    push(...toVarLen(ev.tick - lastTick), ev.type, ...ev.data);
    lastTick = ev.tick;
  }
  push(0x00, 0xFF, 0x2F, 0x00);

  return new Uint8Array([
    0x4D,0x54,0x68,0x64, ...uint32BE(6), ...uint16BE(0), ...uint16BE(1), ...uint16BE(TICKS_PER_BEAT),
    0x4D,0x54,0x72,0x6B, ...uint32BE(td.length), ...td,
  ]);
}

/* ═══════════════════════════════════════════════════════
   AUDIO PLAYBACK
═══════════════════════════════════════════════════════ */
function initSynth(styleName) {
  if (synth) { synth.dispose(); synth = null; }
  const reverb = new Tone.Reverb({ decay: 1.2, wet: 0.15 }).toDestination();
  const chorus = new Tone.Chorus(3, 2, 0.3).connect(reverb);
  chorus.start();

  if (styleName === 'Metal' || styleName === 'Rock Clássico') {
    const dist = new Tone.Distortion(styleName === 'Metal' ? 0.7 : 0.4).connect(chorus);
    synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'sawtooth' },
      envelope: { attack: 0.004, decay: 0.08, sustain: 0.4, release: 0.6 },
    }).connect(dist);
  } else if (styleName === 'Funk') {
    const filter = new Tone.AutoFilter({ frequency: '8n', depth: 0.8 }).connect(chorus);
    filter.start();
    synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.002, decay: 0.05, sustain: 0.1, release: 0.2 },
    }).connect(filter);
  } else {
    synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.005, decay: 0.15, sustain: 0.5, release: 0.9 },
    }).connect(chorus);
  }
  synth.volume.value = -6;
}

function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }

function scheduleTone(notes, bpm, styleName, onDone) {
  Tone.Transport.stop();
  Tone.Transport.cancel();
  if (part) { part.dispose(); part = null; }
  initSynth(styleName);
  Tone.Transport.bpm.value = bpm;

  const secPerTick = 60 / (bpm * TICKS_PER_BEAT);
  const toneNotes = notes.map(n => ({
    time: n.startTick * secPerTick,
    freq: midiToFreq(n.pitch),
    dur: Math.max(0.02, n.durationTicks * secPerTick),
    vel: n.velocity / 127,
  }));
  const totalDur = Math.max(...toneNotes.map(n => n.time + n.dur)) + 0.5;

  part = new Tone.Part((time, ev) => {
    synth.triggerAttackRelease(ev.freq, ev.dur, time, ev.vel);
  }, toneNotes);
  part.start(0);
  Tone.Transport.start();
  setTimeout(() => { Tone.Transport.stop(); onDone(); }, totalDur * 1000 + 200);
}

/* ═══════════════════════════════════════════════════════
   PIANO ROLL
═══════════════════════════════════════════════════════ */
let lastSectionOffsets = [];

function renderPianoRoll(notes) {
  const canvas = $('pianoRoll');
  const ctx = canvas.getContext('2d');
  if (!notes.length) return;

  const pitches = notes.map(n => n.pitch);
  const minP = Math.min(...pitches) - 2;
  const maxP = Math.max(...pitches) + 2;
  const pitchSpan = maxP - minP;

  const maxTick = Math.max(...notes.map(n => n.startTick + n.durationTicks)) + TICKS_PER_BEAT;
  const W = canvas.offsetWidth || 740;
  const H = Math.max(100, pitchSpan * 12);
  canvas.width = W; canvas.height = H; canvas.style.height = H + 'px';

  ctx.fillStyle = '#111'; ctx.fillRect(0, 0, W, H);

  const rowH = H / pitchSpan;
  const tickW = W / maxTick;

  // Section backgrounds
  const sectionColors = ['rgba(232,93,4,0.04)', 'rgba(52,152,219,0.04)', 'rgba(46,204,113,0.04)', 'rgba(155,89,182,0.04)'];
  const sectionNames = [...new Set(state.arrangement)];
  lastSectionOffsets.forEach(so => {
    const cIdx = sectionNames.indexOf(so.name) % sectionColors.length;
    ctx.fillStyle = sectionColors[cIdx];
    ctx.fillRect(so.startTick * tickW, 0, (so.endTick - so.startTick) * tickW, H);
  });

  // Beat grid
  ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
  for (let t = 0; t < maxTick; t += TICKS_PER_BEAT) {
    const x = t * tickW;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  for (let t = 0; t < maxTick; t += TICKS_PER_BAR) {
    const x = t * tickW;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }

  // Notes
  for (const n of notes) {
    const x = n.startTick * tickW;
    const w = Math.max(2, n.durationTicks * tickW - 1);
    const y = (maxP - n.pitch) * rowH;
    const h = Math.max(3, rowH - 1);
    const bright = 0.5 + (n.velocity / 127) * 0.5;
    ctx.fillStyle = `hsl(25, 90%, ${Math.round(bright * 60)}%)`;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 2); ctx.fill();
    ctx.fillStyle = `rgba(255,255,255,${bright * 0.18})`;
    ctx.fillRect(x + 1, y + 1, w - 2, h * 0.3);
  }

  // Pitch labels
  ctx.font = '9px monospace'; ctx.fillStyle = 'rgba(255,255,255,0.3)';
  const NN = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  for (let p = minP; p <= maxP; p++) {
    if (p % 12 === 0 || NN[((p % 12) + 12) % 12] === 'E') {
      ctx.fillText(NN[((p % 12) + 12) % 12] + Math.floor(p / 12 - 1), 3, (maxP - p) * rowH + rowH * 0.75);
    }
  }

  // Section markers below piano roll
  renderSectionMarkers(maxTick, W);
}

function renderSectionMarkers(maxTick, totalW) {
  const container = $('sectionMarkers');
  const sectionColors = ['#e85d04', '#3498db', '#2ecc71', '#9b59b6'];
  const sectionNames = [...new Set(state.arrangement)];

  container.innerHTML = '';
  for (const so of lastSectionOffsets) {
    const frac = (so.endTick - so.startTick) / maxTick;
    const cIdx = sectionNames.indexOf(so.name) % sectionColors.length;
    const el = document.createElement('div');
    el.className = 'section-marker';
    el.style.flex = `0 0 ${frac * 100}%`;
    el.style.borderColor = sectionColors[cIdx];
    el.style.color = sectionColors[cIdx];
    el.textContent = so.name;
    container.appendChild(el);
  }
}

/* ═══════════════════════════════════════════════════════
   UI RENDERING
═══════════════════════════════════════════════════════ */
function renderSections() {
  const container = $('sectionsList');
  container.innerHTML = '';
  const canRemove = state.sections.length > 1;

  for (const sec of state.sections) {
    const card = document.createElement('div');
    card.className = 'section-card';
    card.innerHTML = `
      <div class="section-header">
        <span class="section-name">${sec.name}</span>
        <button class="btn-danger-outline btn-xs btn-remove" data-id="${sec.id}" ${canRemove ? '' : 'disabled'}>Remover</button>
      </div>
      <div class="section-controls-row">
        <div class="control-group">
          <span class="section-label">Estilo</span>
          <select class="sec-style" data-id="${sec.id}">
            ${Object.keys(STYLE_DEFS).map(s => `<option ${s === sec.style ? 'selected' : ''}>${s}</option>`).join('')}
          </select>
        </div>
        <div class="control-group">
          <span class="section-label">Compassos</span>
          <select class="sec-bars" data-id="${sec.id}">
            ${[1,2,4,8].map(b => `<option value="${b}" ${b === sec.bars ? 'selected' : ''}>${b}</option>`).join('')}
          </select>
        </div>
        <div class="control-group">
          <span class="section-label">Complexidade</span>
          <select class="sec-complexity" data-id="${sec.id}">
            ${['Simples','Médio','Complexo'].map(c => `<option ${c === sec.complexity ? 'selected' : ''}>${c}</option>`).join('')}
          </select>
        </div>
        <div class="control-group">
          <span class="section-label">Modo de Notas</span>
          <select class="sec-notemode" data-id="${sec.id}">
            <option value="random" ${sec.noteMode === 'random' ? 'selected' : ''}>Escala Aleatória</option>
            <option value="progression" ${sec.noteMode === 'progression' ? 'selected' : ''}>Progressão de Acordes</option>
            <option value="motif" ${sec.noteMode === 'motif' ? 'selected' : ''}>Motivo + Variação</option>
          </select>
        </div>
      </div>
      <div class="section-toggles">
        <label class="toggle-label">
          <input type="checkbox" class="sec-power" data-id="${sec.id}" ${sec.powerChords ? 'checked' : ''} />
          Power Chords (root+5th+8va)
        </label>
        <label class="toggle-label">
          <input type="checkbox" class="sec-palm" data-id="${sec.id}" ${sec.palmMute ? 'checked' : ''} />
          Palm Mute
        </label>
      </div>
      <div class="progression-editor" data-id="${sec.id}" style="display:${sec.noteMode === 'progression' ? 'block' : 'none'}">
        <span class="section-label">Progressão:</span>
        <div class="progression-row" data-id="${sec.id}">
          ${sec.chordProgression.map((deg, i) => `
            <select class="prog-degree" data-id="${sec.id}" data-idx="${i}">
              ${DEGREE_NAMES.map(d => `<option ${d === deg ? 'selected' : ''}>${d}</option>`).join('')}
            </select>
          `).join('')}
          <button class="btn-xs btn-secondary prog-add" data-id="${sec.id}">+</button>
          <button class="btn-xs btn-danger-outline prog-remove" data-id="${sec.id}" ${sec.chordProgression.length <= 2 ? 'disabled' : ''}>-</button>
        </div>
      </div>
      <div style="margin-top:0.5rem">
        <span class="section-label">Ritmo (16th notes):</span>
        <div class="rhythm-grid" data-id="${sec.id}" style="margin-top:0.3rem">
          ${[0,1,2,3].map(beat => `
            <div class="beat-group">
              ${[0,1,2,3].map(sub => {
                const idx = beat * 4 + sub;
                return `<div class="grid-cell ${sec.rhythm[idx] ? 'active' : ''}" data-id="${sec.id}" data-step="${idx}"></div>`;
              }).join('')}
            </div>
          `).join('')}
        </div>
      </div>
    `;
    container.appendChild(card);
  }

  // Event listeners
  container.querySelectorAll('.btn-remove').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = parseInt(btn.dataset.id);
      const sec = state.sections.find(s => s.id === id);
      state.sections = state.sections.filter(s => s.id !== id);
      state.arrangement = state.arrangement.filter(n => n !== sec.name || state.sections.some(s => s.name === n));
      if (!state.arrangement.length && state.sections.length) state.arrangement = [state.sections[0].name];
      renderAll();
    });
  });

  container.querySelectorAll('.sec-style').forEach(sel => {
    sel.addEventListener('change', () => {
      const sec = state.sections.find(s => s.id === parseInt(sel.dataset.id));
      sec.style = sel.value;
      sec.rhythm = [...DEFAULT_RHYTHMS[sel.value]];
      renderSections();
    });
  });

  container.querySelectorAll('.sec-bars').forEach(sel => {
    sel.addEventListener('change', () => {
      const sec = state.sections.find(s => s.id === parseInt(sel.dataset.id));
      sec.bars = parseInt(sel.value);
    });
  });

  container.querySelectorAll('.sec-complexity').forEach(sel => {
    sel.addEventListener('change', () => {
      const sec = state.sections.find(s => s.id === parseInt(sel.dataset.id));
      sec.complexity = sel.value;
    });
  });

  container.querySelectorAll('.sec-notemode').forEach(sel => {
    sel.addEventListener('change', () => {
      const sec = state.sections.find(s => s.id === parseInt(sel.dataset.id));
      sec.noteMode = sel.value;
      const progEditor = container.querySelector(`.progression-editor[data-id="${sec.id}"]`);
      if (progEditor) progEditor.style.display = sel.value === 'progression' ? 'block' : 'none';
    });
  });

  container.querySelectorAll('.sec-power').forEach(chk => {
    chk.addEventListener('change', () => {
      const sec = state.sections.find(s => s.id === parseInt(chk.dataset.id));
      sec.powerChords = chk.checked;
    });
  });

  container.querySelectorAll('.sec-palm').forEach(chk => {
    chk.addEventListener('change', () => {
      const sec = state.sections.find(s => s.id === parseInt(chk.dataset.id));
      sec.palmMute = chk.checked;
    });
  });

  container.querySelectorAll('.grid-cell').forEach(cell => {
    cell.addEventListener('click', () => {
      const sec = state.sections.find(s => s.id === parseInt(cell.dataset.id));
      const step = parseInt(cell.dataset.step);
      sec.rhythm[step] = sec.rhythm[step] ? 0 : 1;
      cell.classList.toggle('active');
    });
  });

  container.querySelectorAll('.prog-degree').forEach(sel => {
    sel.addEventListener('change', () => {
      const sec = state.sections.find(s => s.id === parseInt(sel.dataset.id));
      sec.chordProgression[parseInt(sel.dataset.idx)] = sel.value;
    });
  });

  container.querySelectorAll('.prog-add').forEach(btn => {
    btn.addEventListener('click', () => {
      const sec = state.sections.find(s => s.id === parseInt(btn.dataset.id));
      if (sec.chordProgression.length < 8) {
        sec.chordProgression.push('I');
        renderSections();
      }
    });
  });

  container.querySelectorAll('.prog-remove').forEach(btn => {
    btn.addEventListener('click', () => {
      const sec = state.sections.find(s => s.id === parseInt(btn.dataset.id));
      if (sec.chordProgression.length > 2) {
        sec.chordProgression.pop();
        renderSections();
      }
    });
  });
}

function renderArrangement() {
  // Chips
  const chips = $('arrangementChips');
  chips.innerHTML = '';
  state.arrangement.forEach((name, idx) => {
    const chip = document.createElement('div');
    chip.className = 'arr-chip';
    chip.innerHTML = `${name} <span class="arr-remove" data-idx="${idx}">&times;</span>`;
    chips.appendChild(chip);
  });
  chips.querySelectorAll('.arr-remove').forEach(btn => {
    btn.addEventListener('click', () => {
      state.arrangement.splice(parseInt(btn.dataset.idx), 1);
      renderArrangement();
    });
  });

  // Add buttons
  const addBtns = $('addArrBtns');
  addBtns.innerHTML = '';
  for (const sec of state.sections) {
    const btn = document.createElement('button');
    btn.className = 'btn-secondary btn-xs';
    btn.textContent = `+ ${sec.name}`;
    btn.addEventListener('click', () => {
      state.arrangement.push(sec.name);
      renderArrangement();
    });
    addBtns.appendChild(btn);
  }
}

function renderAll() {
  renderSections();
  renderArrangement();
}

/* ═══════════════════════════════════════════════════════
   PRESETS
═══════════════════════════════════════════════════════ */
const PRESETS = {
  'power-rock': {
    key: 'A', scale: 'Pentatônica Menor', bpm: 128, velocity: 100,
    sections: [
      { name: 'A', bars: 2, style: 'Rock Clássico', complexity: 'Médio', powerChords: true, palmMute: false,
        noteMode: 'progression', chordProgression: ['I', 'bVII', 'IV', 'I'],
        rhythm: [1,0,0,0, 1,0,1,0, 0,0,1,0, 1,0,0,0] },
      { name: 'B', bars: 2, style: 'Rock Clássico', complexity: 'Complexo', powerChords: false, palmMute: false,
        noteMode: 'motif', chordProgression: ['I', 'IV'],
        rhythm: [1,0,1,0, 0,1,1,0, 0,0,1,0, 1,0,1,0] },
    ],
    arrangement: ['A', 'A', 'B', 'A'],
  },
  'blues-shuffle': {
    key: 'E', scale: 'Blues', bpm: 100, velocity: 85,
    sections: [
      { name: 'A', bars: 2, style: 'Blues Shuffle', complexity: 'Médio', powerChords: false, palmMute: false,
        noteMode: 'progression', chordProgression: ['I', 'IV', 'I', 'V'],
        rhythm: [1,0,1,0, 0,0,1,0, 0,1,1,0, 1,0,0,0] },
      { name: 'B', bars: 2, style: 'Blues Shuffle', complexity: 'Complexo', powerChords: false, palmMute: false,
        noteMode: 'random', chordProgression: ['I', 'IV'],
        rhythm: [1,0,0,1, 0,1,0,0, 1,0,1,0, 0,0,1,0] },
    ],
    arrangement: ['A', 'A', 'B', 'A'],
  },
  'metal': {
    key: 'D', scale: 'Menor Natural', bpm: 160, velocity: 115,
    sections: [
      { name: 'A', bars: 2, style: 'Metal', complexity: 'Complexo', powerChords: true, palmMute: true,
        noteMode: 'progression', chordProgression: ['I', 'bII', 'bVII', 'I'],
        rhythm: [1,1,0,1, 1,0,1,1, 0,1,1,0, 1,1,0,1] },
      { name: 'B', bars: 1, style: 'Metal', complexity: 'Médio', powerChords: true, palmMute: false,
        noteMode: 'motif', chordProgression: ['I', 'V'],
        rhythm: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0] },
    ],
    arrangement: ['A', 'A', 'A', 'B'],
  },
  'funk': {
    key: 'E', scale: 'Dórica', bpm: 108, velocity: 88,
    sections: [
      { name: 'A', bars: 2, style: 'Funk', complexity: 'Complexo', powerChords: false, palmMute: true,
        noteMode: 'random', chordProgression: ['I', 'IV'],
        rhythm: [1,0,0,1, 0,1,0,0, 1,0,0,1, 0,0,1,0] },
      { name: 'B', bars: 2, style: 'Funk', complexity: 'Médio', powerChords: false, palmMute: false,
        noteMode: 'progression', chordProgression: ['I', 'IV', 'bVII', 'IV'],
        rhythm: [1,0,1,0, 0,0,1,1, 0,1,0,0, 1,0,1,0] },
    ],
    arrangement: ['A', 'B', 'A', 'B'],
  },
  'pentatonic': {
    key: 'A', scale: 'Pentatônica Menor', bpm: 115, velocity: 90,
    sections: [
      { name: 'A', bars: 2, style: 'Alternativo', complexity: 'Médio', powerChords: false, palmMute: false,
        noteMode: 'motif', chordProgression: ['I', 'IV'],
        rhythm: [1,0,1,0, 0,1,0,0, 1,0,0,1, 0,1,0,0] },
    ],
    arrangement: ['A', 'A'],
  },
};

function applyPreset(presetName) {
  const p = PRESETS[presetName];
  if (!p) return;

  $('selKey').value = p.key;
  $('selScale').value = p.scale;
  $('rangeBpm').value = p.bpm; $('bpmVal').textContent = p.bpm;
  $('rangeVelocity').value = Math.min(127, p.velocity); $('velVal').textContent = Math.min(127, p.velocity);

  sectionIdCounter = 0;
  state.sections = p.sections.map(s => createSection(s.name, {
    bars: s.bars, style: s.style, complexity: s.complexity,
    powerChords: s.powerChords, palmMute: s.palmMute,
    noteMode: s.noteMode, chordProgression: [...s.chordProgression],
    rhythm: [...s.rhythm],
  }));
  state.arrangement = [...p.arrangement];
  renderAll();
  setStatus(`Preset "${presetName}" carregado`, 'ok');
}

/* ═══════════════════════════════════════════════════════
   ACTIONS
═══════════════════════════════════════════════════════ */
function setStatus(msg, cls = '') {
  $('status').textContent = msg;
  $('status').className = cls;
}

function onGenerate() {
  if (!state.arrangement.length) {
    setStatus('Adicione pelo menos uma seção no arranjo.', 'err');
    return;
  }
  setStatus('Gerando riff...', '');

  const { notes, sectionOffsets } = generateFullRiff();
  lastSectionOffsets = sectionOffsets;
  currentNotes = notes;

  // Determine MIDI program from first section
  const firstSec = state.sections.find(s => s.name === state.arrangement[0]);
  const program = firstSec ? STYLE_DEFS[firstSec.style].program : 30;
  const bpm = parseInt($('rangeBpm').value);
  currentMIDI = buildMIDI(notes, bpm, program);

  $('emptyMsg').style.display = 'none';
  $('pianoRoll').style.display = 'block';
  renderPianoRoll(notes);

  $('btnPlay').disabled = false;
  $('btnDownload').disabled = false;

  const totalSec = notes.length
    ? (Math.max(...notes.map(n => n.startTick + n.durationTicks)) / TICKS_PER_BEAT / bpm * 60).toFixed(1)
    : 0;
  const unique = new Set(notes.map(n => n.pitch)).size;
  $('infoBar').innerHTML = `
    <span>Tom: <strong>${$('selKey').value}</strong></span>
    <span>Escala: <strong>${$('selScale').value}</strong></span>
    <span>BPM: <strong>${bpm}</strong></span>
    <span>Seções: <strong>${state.arrangement.join(' ')}</strong></span>
    <span>Notas: <strong>${notes.length}</strong></span>
    <span>Únicas: <strong>${unique}</strong></span>
    <span>Duração: <strong>~${totalSec}s</strong></span>
  `;
  setStatus(`Riff gerado com ${notes.length} notas em ${state.arrangement.length} seções!`, 'ok');
}

async function onPlay() {
  if (isPlaying || !currentNotes) return;
  await Tone.start();
  const bpm = parseInt($('rangeBpm').value);
  const firstSec = state.sections.find(s => s.name === state.arrangement[0]);
  const styleName = firstSec ? firstSec.style : 'Rock Clássico';

  isPlaying = true;
  $('btnPlay').disabled = true;
  $('btnStop').disabled = false;
  setStatus('Tocando...', '');

  const canvas = $('pianoRoll');
  const maxTick = Math.max(...currentNotes.map(n => n.startTick + n.durationTicks)) + TICKS_PER_BEAT;
  const totalMs = (maxTick / TICKS_PER_BEAT / bpm * 60 * 1000) + 300;
  const startTime = Date.now();
  $('playhead').style.display = 'block';

  playheadTimer = setInterval(() => {
    const frac = Math.min(1, (Date.now() - startTime) / totalMs);
    $('playhead').style.left = (frac * canvas.offsetWidth) + 'px';
  }, 40);

  scheduleTone(currentNotes, bpm, styleName, stopPlayback);
}

function stopPlayback() {
  isPlaying = false;
  Tone.Transport.stop();
  if (part) { part.dispose(); part = null; }
  clearInterval(playheadTimer);
  $('playhead').style.display = 'none';
  $('btnPlay').disabled = false;
  $('btnStop').disabled = true;
  setStatus('');
}

function onDownload() {
  if (!currentMIDI) return;
  const key = $('selKey').value.replace('/', '_');
  const bpm = $('rangeBpm').value;
  const blob = new Blob([currentMIDI], { type: 'audio/midi' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `riff_${key}_${bpm}bpm_${state.arrangement.join('')}.mid`;
  a.click();
  URL.revokeObjectURL(url);
  setStatus('MIDI baixado!', 'ok');
}

/* ═══════════════════════════════════════════════════════
   INIT & EVENTS
═══════════════════════════════════════════════════════ */
$('rangeBpm').addEventListener('input', e => { $('bpmVal').textContent = e.target.value; });
$('rangeVelocity').addEventListener('input', e => { $('velVal').textContent = e.target.value; });
$('btnGenerate').addEventListener('click', onGenerate);
$('btnPlay').addEventListener('click', onPlay);
$('btnStop').addEventListener('click', stopPlayback);
$('btnDownload').addEventListener('click', onDownload);

$('btnAddSection').addEventListener('click', () => {
  const names = state.sections.map(s => s.name);
  const next = String.fromCharCode(65 + names.length); // A, B, C...
  const newName = names.includes(next) ? next + '2' : next;
  state.sections.push(createSection(newName));
  renderAll();
});

// Preset buttons
document.querySelectorAll('[data-preset]').forEach(btn => {
  btn.addEventListener('click', () => applyPreset(btn.dataset.preset));
});

// Resize
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    if (currentNotes) renderPianoRoll(currentNotes);
  }, 200);
});

// Initial render
renderAll();
</script>
</body>
</html>
